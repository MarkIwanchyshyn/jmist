/**
 *
 */
package ca.eandb.jmist.framework;

import java.io.Serializable;

import ca.eandb.jmist.math.Box3;
import ca.eandb.jmist.math.Ray3;
import ca.eandb.jmist.math.Sphere;

/**
 * The basic component of a scene description.
 * 
 * A <code>SceneElement</code>:
 * <ul>
 *   <li>Can test visibility between two points, or along a ray.</li>
 *   <li>Can be queried for ray-intersections along a ray.</li>
 *   <li>Knows about the light sources within it which have a physical
 *   	manifestation (i.e. light-emitting geometry, as oposed to point light
 *   	sources.</li>
 *   <li>Can generate random <code>SurfacePoint</code>s over the geometry they
 *   	represent (optional operation).</li>
 *   <li>May apply <code>Material</code>s or <code>Shader</code>s to the
 *   	<code>Intersection</code>s and <code>SurfacePoint</code>s generated by
 *   	its methods.</li>
 *   <li>Is composed of zero or more "primitives".  Many operations may be
 *   	applied to the individual primitives as well as the
 *   	<code>SceneElement</code> as a whole.</li>
 * </ul>
 *  
 * @author Brad Kimmel
 */
public interface SceneElement extends Bounded3, VisibilityFunction3, Serializable {

	/**
	 * Gets the number of primitives contained in this <code>SceneElement</code>.
	 * @return The number of primitives contained in this
	 * 		<code>SceneElement</code>.
	 */
	int getNumPrimitives();

	/**
	 * Computes the intersections between a given ray and the specified
	 * primitive.
	 * @param index The index of the primitive with which to compute
	 * 		intersections.
	 * @param ray A <code>Ray3</code> to intersect with the specified
	 * 		primitive.
	 * @param recorder An <code>IntersectionRecorder</code> to receive the
	 * 		computed intersections.
	 */
	void intersect(int index, Ray3 ray, IntersectionRecorder recorder);

	/**
	 * Computes the intersections between a given ray and this geometry.
	 * @param ray A <code>Ray3</code> to intersect with this geometry.
	 * @param recorder An <code>IntersectionRecorder</code> to receive the
	 * 		computed intersections.
	 */
	void intersect(Ray3 ray, IntersectionRecorder recorder);

	/**
	 * Determines if a given ray intersects with the specified primitive.
	 * @param index The index of the primitive with which to compute
	 * 		intersections.
	 * @param ray A <code>Ray3</code> to intersect with the specified
	 * 		primitive.
	 * @return A value indicating if <code>ray</code> intersects with the
	 * 		specified primitive.
	 */
	boolean visibility(int index, Ray3 ray);

	/**
	 * Determines if the surface of the specified primitive intersects with the
	 * given box.
	 * @param index The index of the primitive for which to determine
	 * 		intersection.
	 * @param box A <code>Box3</code> to intersect with.
	 * @return True if <code>box</code> intersects with the specified primitive
	 * 		or if it cannot be determined whether <code>box</code> intersects
	 * 		with the specified primitive.  False otherwise.
	 */
	boolean intersects(int index, Box3 box);

	/**
	 * Computes a bounding box for the specified primitive.
	 * @param index The index of the primitive for which to compute the
	 * 		bounding box.
	 * @return A <code>Box3</code> containing the primitive.
	 */
	Box3 getBoundingBox(int index);

	/**
	 * Computes a bounding sphere for the specified primitive.
	 * @param index The index of the primitive for which to compute the
	 * 		bounding sphere.
	 * @return A <code>Sphere</code> containing the primitive.
	 */
	Sphere getBoundingSphere(int index);

	/**
	 * Computes the surface area of the specified primitive (optional
	 * operation).
	 * @return The surface area of the primitive.
	 * @throws UnsupportedOperationException If the operation is not
	 * 		supported by this <code>SceneElement</code>.
	 */
	double getSurfaceArea(int index);

	/**
	 * Computes the surface area of this geometry (optional operation).
	 * @return The surface area of this geometry.
	 * @throws UnsupportedOperationException If the operation is not
	 * 		supported by this <code>SceneElement</code>.
	 */
	double getSurfaceArea();

	/**
	 * Generates a <code>SurfacePoint</code> randomly that is uniformly
	 * distributed over the surface of the specified primitive (optional
	 * operation).
	 * @return The randomly generated <code>SurfacePoint</code>.
	 * @throws UnsupportedOperationException If the operation is not supported
	 * 		by this <code>SceneElement</code>.
	 */
	void generateRandomSurfacePoint(int index, ShadingContext context, double ru, double rv, double rj);

	/**
	 * Generates a <code>SurfacePoint</code> randomly that is uniformly
	 * distributed over the surface of this geometry (optional operation).
	 * @return The randomly generated <code>SurfacePoint</code>.
	 * @throws UnsupportedOperationException If the operation is not supported
	 * 		by this <code>SceneElement</code>.
	 */
	void generateRandomSurfacePoint(ShadingContext context, double ru, double rv, double rj);

	/**
	 * Generates a <code>SurfacePoint</code> randomly that is uniformly
	 * distributed over the surface of the specified primitive (optional
	 * operation).
	 * @return The randomly generated <code>SurfacePoint</code>.
	 * @throws UnsupportedOperationException If the operation is not supported
	 * 		by this <code>SceneElement</code>.
	 */
	double generateImportanceSampledSurfacePoint(int index, SurfacePoint x, ShadingContext context, double ru, double rv, double rj);

	/**
	 * Generates a <code>SurfacePoint</code> randomly that is uniformly
	 * distributed over the surface of this geometry (optional operation).
	 * @return The randomly generated <code>SurfacePoint</code>.
	 * @throws UnsupportedOperationException If the operation is not supported
	 * 		by this <code>SceneElement</code>.
	 */
	double generateImportanceSampledSurfacePoint(SurfacePoint x, ShadingContext context, double ru, double rv, double rj);

	/**
	 * Creates a <code>Light</code> from the emissive surfaces in this scene
	 * element.
	 * @return A <code>Light</code> representing the emissive surfaces in this
	 * 		scene element.
	 */
	Light createLight();

}
